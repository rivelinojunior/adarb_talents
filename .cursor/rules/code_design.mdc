---
description: Code design
globs: 
alwaysApply: true
---
# Code design

Great developers donâ€™t just write codeâ€”they craft solutions that solve real problems and evolve alongside business needs. You are a good developer aiming for:
- Simplicity that scales
- Fast changeability
- Sustainable pace
Code should be understandable, cohesive, and easy to change, so teams can move fast without breaking things.

## Cohesion and Coupling
- Cohesion means "things that make sense together."  
- Coupling means "things that are connected."
> â€œGather into the same class or component those elements that change for the same reason.â€  
> â€” Based on SRP, OCP, and CCP
If your code makes sense to everyone on the team, itâ€™s easier to read, test, change, and reuse.

## Test-Driven Development (TDD)
- Write reliable and readable tests.
- Avoid writing tests just to increase coverage or pass CI.
- Trustworthy tests make refactoring safe and fast.

## Naming Things Well
- Use names that express intent, context, and purpose.
- Refactor names as understanding grows.
- Choose names that are clear and concise and are aligned with the business domain.

## Design by Contract
Define clear and strict contracts:
- Ensure valid inputs
- Guarantee expected outputs
- Use interfaces to abstract internal mechanics (Dependency Rule from Clean Architecture)

## Object-Oriented Principles
- Tell, donâ€™t ask
- DRY (Donâ€™t Repeat Yourself) 
- Law of Demeter (talk to friends, not strangers)

## SOLID Principles

### SRP â€” Single Responsibility Principle
> â€œA class should have one, and only one, reason to change.â€ â€” Robert C. Martin  
> â€œSeparate things that change for different reasons.â€ â€” David Parnas

- Let names define responsibility and reason to change
- Helps with cohesion and simplification

### OCP â€” Open/Closed Principle
> â€œSoftware entities should be open for extension, but closed for modification.â€ â€” Bertrand Meyer

- Achieved through abstractions and polymorphism

### LSP â€” Liskov Substitution Principle
> â€œSubtypes must be substitutable for their base types.â€ â€” Bertrand Meyer

- Interfaces should be clear and consistent
- Avoid breaking expected behavior when substituting implementations

### ISP â€” Interface Segregation Principle
- Clients should not be forced to depend on unused methods
- Prefer small, role-specific interfaces

### DIP â€” Dependency Inversion Principle
> â€œDepend on abstractions, not concretions.â€
- High-level code should not depend on low-level implementation details
- Use inversion of control and dependency injection

## ğŸ›ï¸ Architecture Principles

### CCP â€” Common Closure Principle
> â€œClasses that change together, belong together.â€

### CRP â€” Common Reuse Principle
> â€œClasses that arenâ€™t reused together should not be grouped together.â€

### ADP â€” Acyclic Dependencies Principle
> â€œPackage dependencies should form a Directed Acyclic Graph (DAG).â€

